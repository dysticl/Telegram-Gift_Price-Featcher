from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import uvicorn
import asyncio
import os
from typing import List, Dict

# Import our fetcher modules
from gifts_fetcher import fetcher_instance as gift_service
from price_fetcher import PriceFetcher

app = FastAPI()

# Mount static directory for frontend
app.mount("/static", StaticFiles(directory="static"), name="static")

price_service = PriceFetcher()

# In-memory cache
CACHE = {
    "gifts": [],
    "prices": {},
    "last_updated": 0
}

@app.on_event("startup")
async def startup_event():
    # Check for MOCK_MODE
    if os.getenv("MOCK_MODE") == "true":
        print("!!! RUNNING IN MOCK MODE !!! No Telegram connection required.")
        return

    # Start the Telethon client
    try:
        await gift_service.ensure_started()
    except Exception as e:
        print(f"Warning: Could not start GiftFetcher on startup: {e}")

@app.on_event("shutdown")
async def shutdown_event():
    await gift_service.stop()

@app.get("/")
async def read_root():
    return FileResponse('static/index.html')

@app.get("/api/portfolio")
async def get_portfolio():
    # MOCK MODE DATA
    if os.getenv("MOCK_MODE") == "true":
        return {
            "total_value_ton": 1250.5,
            "total_items": 4,
            "gifts": [
                {
                    "name": "Toy Bear",
                    "details": "Wizard",
                    "image_url": "https://cache.tonapi.io/imgproxy/b2a7eb46522c0926d2d46816027d14df2011158d/aHR0cHM6Ly9uZnQudG9uZGlhbW9uZHMuY29tL25ZnQtZ2lmdHMvYXBpL3YxL3RvbnBsYW5ldC9naWZ0cy8xL2ltYWdl.webp", # Real toy bear url example
                    "price": 50.0,
                    "num": 1337
                },
                {
                    "name": "Lunar Snake",
                    "details": "Albino (1.5%)",
                    "image_url": "https://cache.tonapi.io/imgproxy/4e6221f75960000a6230894ff9c687e35759ce91/aHR0cHM6Ly9uZnQudG9uZGlhbW9uZHMuY29tL25ZnQtZ2lmdHMvYXBpL3YxL3RvbnBsYW5ldC9naWZ0cy8yL2ltYWdl.webp", # Real snake url example
                    "price": 1200.5,
                    "num": 42
                },
                 {
                    "name": "Star",
                    "details": "Meteor",
                    "image_url": "", 
                    "price": 0,
                    "num": 99999
                }
            ],
            "debug_prices": {"Mock": "True"}
        }

    try:
        user_gifts = await gift_service.get_gifts()
        print(f"DEBUG: Raw Gifts Data: {user_gifts}") # Debug print
    except Exception as e:
        print(f"API Error fetching gifts: {e}")
        return {"error": "Could not fetch gifts. Check server logs/login."}

    # 2. Fetch Prices
    market_prices = {}
    
    # PRIORITY: Load REAL prices from JSON if available (generated by fetch_real_prices.py)
    if os.path.exists("market_prices.json"):
        try:
            with open("market_prices.json", "r") as f:
                market_prices = json.load(f)
            print(f"Loaded {len(market_prices)} REAL prices from market_prices.json")
        except Exception as e:
            print(f"Error loading price JSON: {e}")

    # Fallback: If no local prices, use the fetcher (mock/api fallback)
    if not market_prices: 
        print("Using Fallback/Mock Prices")
        tonnel_prices = price_service.fetch_tonnel_prices()
        if tonnel_prices: market_prices.update(tonnel_prices)


    # 3. Match Gifts to Prices
    total_value = 0.0
    enriched_gifts = []
    
    for g in user_gifts:
        # g is now a clean dict: {'id', 'name', 'details', 'price', ...}
        
        gift_name = g.get('name', 'Unknown')
        gift_price = 0.0
        
        # Try exact match
        if gift_name in market_prices:
            gift_price = market_prices[gift_name]
        else:
            # Try fuzzy/partial match 
            # e.g. "Toy Bear" vs "Toy Bear - Wizard"
            # We look for the base name in the market keys
            for key, val in market_prices.items():
                if gift_name in key:
                    # Use this price? Or keep looking for best match?
                    # For now take first match
                    gift_price = val
                    break
        
        # Override price in gift object
        g['price'] = float(gift_price)
        total_value += g['price']
        
        # Pass through keys
        enriched_gifts.append(g)

    return {
        "total_value_ton": total_value,
        "total_items": len(user_gifts),
        "gifts": enriched_gifts,
        "debug_prices": market_prices
    }

    return {
        "total_value_ton": total_value,
        "total_items": len(user_gifts),
        "gifts": enriched_gifts,
        "debug_prices": market_prices
    }

if __name__ == "__main__":
    uvicorn.run("server:app", host="0.0.0.0", port=8000, reload=True)
